/*
	DE1_SoC serves as the top-level module, relaying coordinates generated by clear_screen and sim_calculation,
	through line_drawer, to VGA_framebuffer, to be outputted onto the VGA display.
	The module utilizes two sanitized key inputs to start the animation (KEY[0]), and clear the screen (KEY[3]).
	
	clear_screen and sim_calculator each output coordinates to line_drawer. However, only one set of output coordinates
	are transmitted at a time. Priority is given to clear_screen, i.e., sim_calculator cannot begin its animation if 
	clear_screen is 'busy' (indicated by the assertion of 1-bit internal signal black). This signal is additionally used
	to control the pixel color written into the VGA buffer.
	
	The coordinates generated by line_drawer are sent to VGA_framebuffer, which regulates the numerous signals sent to the VGA display.
*/

module DE1_SoC #(parameter sim_timer = 50000000) (KEY, CLOCK_50, 
	VGA_R, VGA_G, VGA_B, VGA_BLANK_N, VGA_CLK, VGA_HS, VGA_SYNC_N, VGA_VS);
	
	// KEY inputs regulate start/reset.
	input logic [3:0] KEY;
	input CLOCK_50;
	
	// signals to VGA display.
	output [7:0] VGA_R;
	output [7:0] VGA_G;
	output [7:0] VGA_B;
	output VGA_BLANK_N;
	output VGA_CLK;
	output VGA_HS;
	output VGA_SYNC_N;
	output VGA_VS;
	
	// Coordinates sent and outputted to/by line_drawer. clear and calc coordinates are the
	// outputs of clear_screen and sim_calculator, respectively.
	logic [9:0] x0, x1, clear_x0, clear_x1, calc_x0, calc_x1, x;
	logic [8:0] y0, y1, clear_y0, clear_y1, calc_y0, calc_y1, y;
	
	logic frame_start;
	logic pixel_color;
	logic clear_set, calc_set, set, reset, start, black; // Black is a priority signal.
	
	
	//////// DOUBLE_FRAME_BUFFER ////////
	logic dfb_en;
	assign dfb_en = 1'b0;
	/////////////////////////////////////
	
	// set and reset are sanitized to ensure that assertion is pulsed over one cycle.
	input_sanitizer sanitized_start (.clk(CLOCK_50), .reset(1'b0), .in(~KEY[0]), .out(start));
	input_sanitizer sanitized_reset (.clk(CLOCK_50), .reset(1'b0), .in(~KEY[3]), .out(reset));
	
	// Instance of clear_screen, with I/O described above.
	clear_screen blank (.clk(CLOCK_50), .reset(1'b0), .start(reset), .x0(clear_x0), 
								.y0(clear_y0), .x1(clear_x1), .y1(clear_y1), .set(clear_set), .black);
	
	// Instance of sim_calculator, with I/O described above.
	sim_calculator #(sim_timer) inputs (.clk(CLOCK_50), .reset, .start(start & ~black), .x0(calc_x0), .y0(calc_y0), 
								.x1(calc_x1), .y1(calc_y1), .set(calc_set)); // we cannot start the animation while we are clearing the screen.
	
	// Choosing the inputs to line_drawer.
	always_comb begin
		if (black) begin
			set = clear_set;
			x0 = clear_x0; x1 = clear_x1; y0 = clear_y0; y1 = clear_y1;
		end
		else begin
			set = calc_set;
			x0 = calc_x0; x1 = calc_x1; y0 = calc_y0; y1 = calc_y1;
		end
	end
	
	// draw lines between (x0, y0) and (x1, y1)
	line_drawer lines (.clk(CLOCK_50), .reset,
				.x0, .y0, .x1, .y1, .x, .y, .set);
	
	// Choosing pixel_color.
	assign pixel_color = (black) ? 1'b0 : 1'b1;
	
	// Coordinates are written to framebuffer and outputted to VGA.
	VGA_framebuffer fb(.clk(CLOCK_50), .rst(1'b0), .x, .y,
				.pixel_color, .pixel_write(1'b1), .dfb_en, .frame_start,
				.VGA_R, .VGA_G, .VGA_B, .VGA_CLK, .VGA_HS, .VGA_VS,
				.VGA_BLANK_N, .VGA_SYNC_N);
	
endmodule


/* 
	Testbench is designed to check that priority between clear_screen and sim_calculator is properly handled.
	We test that 1. starting the animation while clearing the screen is invalid.
	2. The animation is functional when we are not clearing the screen.
	3. Resetting the animation before completion gives priority to clear_screen.
*/

module DE1_SoC_testbench();
	logic [3:0] KEY;
	logic CLOCK_50;
	
	DE1_SoC #(2000) dut (.KEY, .CLOCK_50); 
	// sim_timer set to 2000 - don't need to wait 1 second between subsequent animation lines.
	
	parameter clock_period = 20;
	initial begin
		CLOCK_50 <= 0;
		forever #(clock_period/2) CLOCK_50 <= ~CLOCK_50;
	end
	
	initial begin
		KEY[3] <= 0; KEY[0] <= 1;		@(posedge CLOCK_50)
		KEY[3] <= 1; 				@(posedge CLOCK_50)
		repeat(500000)				@(posedge CLOCK_50);
		KEY[0] <= 0;				@(posedge CLOCK_50)
		KEY[0] <= 1;				@(posedge CLOCK_50) // attempt to start animation before screen is cleared.
		repeat(500000)				@(posedge CLOCK_50);
		KEY[0] <= 0;				@(posedge CLOCK_50)
		KEY[0] <= 1;				@(posedge CLOCK_50) // clear should now be complete. Start animation.
		repeat (50000) 				@(posedge CLOCK_50);
		KEY[0] <= 0;				@(posedge CLOCK_50)
		KEY[0] <= 1;				@(posedge CLOCK_50) 
		repeat (25000) 				@(posedge CLOCK_50);
		KEY[3] <= 0; 				@(posedge CLOCK_50)
		KEY[3] <= 1; 				@(posedge CLOCK_50) // Clear before animation is complete.
		repeat(1000000)				@(posedge CLOCK_50);
		$stop;
	end
endmodule
